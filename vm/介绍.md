## snabbdom
* vue的虚拟dom实现借鉴了snabbdom，这是一个经典的虚拟dom库

### h函数
* h函数`是用来产生vnode虚拟节点的！！！`
* 例如`h('a',{prop:{a:1}},'test')`
* 产生虚拟节点，结果为：`{'sel':'a',data:{prop:{a:1}},text:"test"}`

### diff算法
* `diff过程是在vnode新旧虚拟节点之间进行比较的`
* `diff算法的比较策略是深度优先，同层比较`

### diff算法优化策略
* `按照顺序进行命中（两个节点的key相同，tag相同）查找，命中其中一个就结束本次查找`
1. 新前（新节点的第一个元素）与旧前（旧节点的第一个元素） `(不需要移动节点，只需要移动指针)`
2. 新后（新节点的最后一个元素）与旧后（旧节点的最后一个元素） `(不需要移动节点，只需要移动指针)`
3. 新后与旧前 `(那么新后指向的节点移动到旧后之后)`
4. 新前与旧后 `(那么新前指向的节点移动到旧前之前)`
* `如果以上四种规则都没有命中，那么就要进行顺序查找了(查找可以指向新前的节点，找到后插入到旧前之前。)`
* `如果旧节点先遍历结束，那么新节点新前和新后之间的节点就是插入节点`
* `如果新节点先遍历结束，那么旧节点旧前和旧后之间的节点就是删除节点`  

#### diff例子
1. 新前与旧前
```js
let vnode1 = h('ul',{},[
    h('li',{key:1},'A'),
    h('li',{key:2},'B'),
    h('li',{key:3},'C'),
    h('li',{key:4},'D'),
]);
let vnode2 = h('ul',{},[
    h('li',{key:1},'AA'),
    h('li',{key:2},'B'),
    h('li',{key:3},'C'),
    h('li',{key:4},'D'),
])
```
* 修改旧前节点元素的值就可以了！
* `查找成功的顺序是a,b,c,d`
2. 新后与旧后
```js
let vnode1 = h('ul',{},[
    h('li',{key:1},'A'),
    h('li',{key:2},'B'),
    h('li',{key:3},'C'),
    h('li',{key:4},'D'),
]);
let vnode2 = h('ul',{},[
    h('li',{key:11},'A'),
    h('li',{key:2},'B'),
    h('li',{key:3},'C'),
    h('li',{key:4},'DD'),
])
```
* 由于新前和旧前的key不相同，所以不是同一个节点，所以进入新后和旧后比较
* `查找成功的顺序是DD,C,B;`,`a查找失败，因为key不同，进入顺序遍历阶段`
3. 新后与旧前
```js
let vnode1 = h('ul',{},[
    h('li',{key:1},'A'),
    h('li',{key:2},'B'),
    h('li',{key:3},'C'),
    h('li',{key:4},'D'),
]);
let vnode2 = h('ul',{},[
    h('li',{key:4},'AA'),
    h('li',{key:3},'BB'),
    h('li',{key:2},'CC'),
    h('li',{key:1},'DD'),
])
```
* `由于按照查找方式，是新后与旧前`
* `查找成功的顺序是:DD,CC,BB,AA`
4. 新前与旧后
```js
let vnode1 = h('ul',{},[
    h('li',{key:1},'A'),
    h('li',{key:2},'B'),
    h('li',{key:3},'C'),
    h('li',{key:4},'D'),
]);
let vnode2 = h('ul',{},[
    h('li',{key:4},'AA'),
    h('li',{key:3},'BB'),
    h('li',{key:2},'CC'),
    h('li',{key:11},'DD'),
])
```
* ``


#### 以下demo都需要在vue中验证

#### diff算法中的key的作用
* `一般认为：如果元素tag相同，并且key相同（注意是针对同一级节点的！不会进行跨层比较！），那么就可以认为是同一个虚拟节点`
* 这也就是我们使用列表需要添加key的原因，`如果添加了key,那么遍历的时候就在一开始就知道是元素更新，不需要再继续判断是否元素移动位置了，元素是否被删除了，时间复杂度就降低了！`
* 例子：
* 旧节点
```html
<li>1</li>
<li>2</li>
<li>3</li>
<li>4</li>
```
* 新节点
```html
        <li>5</li>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
```
* `此时由于没有key,需要把节点1覆盖为节点5，后面的1，2，3，4其实都可能被覆盖一次！（具体看diff算法怎么做）`
---
* 如果添加了key，那么此时只需要执行一次添加操作就可以了！
* 旧节点
```html
<li key="1">1</li>
<li key="2">2</li>
<li key="3">3</li>
<li key="4">4</li>
```
* 新节点
```html
        <li key="5">5</li>
        <li key="1">1</li>
        <li key="2">2</li>
        <li key="3">3</li>
        <li key="4">4</li>
```
* `比较key,1和5不一样，而且也不是2，3，4；所以是添加操作，然后再比较，发现1，2，3，4的key都有值，所以只是节点移动了！`

---

#### 不能使用index作为key
* 如果使用index作为key
```html
<li key="1">1</li>
<li key="2">2</li>
<li key="3">3</li>
<li key="4">4</li>
```
* 新节点
```html
        <li key="1">5</li>
        <li key="2">1</li>
        <li key="3">2</li>
        <li key="4">3</li>
        <li key="5">4</li>
```
* `那么其实更新dom之后的key就是这样的，所以就是要执行5次覆盖更新的操作！！！`

#### 只能同层比较
```html
<div id="app">
    <li key="1">1</li>
    <li key="2">2</li>
    <li key="3">3</li>
    <li key="4">4</li>
</div>
```
* 新节点
```html
<div id="app">
    <div id="container">
        <li key="5">5</li>
        <li key="1">1</li>
        <li key="2">2</li>
        <li key="3">3</li>
        <li key="4">4</li>
    </div>
</div>
```
* `由于新节点的li数组和旧节点的li数组不是处于同一层级（新节点位于第三层，旧节点位于第二层），所以无法比较！！！`


#### 父节点必须是同一个虚拟节点
* `必须父节点是同一个虚拟节点才能进行子节点的同层比较！`
```html
<ul>
    <li key="1">1</li>
    <li key="2">2</li>
    <li key="3">3</li>
    <li key="4">4</li>
</ul>
```
* 新节点
```html
<ol>
    <li key="5">5</li>
    <li key="1">1</li>
    <li key="2">2</li>
    <li key="3">3</li>
    <li key="4">4</li>    
</ol>
```
* `由于旧节点的tag是ul,新节点的tag是ol，很明显不是同一个虚拟节点，所以子节点无法进行同层比较！！！`
